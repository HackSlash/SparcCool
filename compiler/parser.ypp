%{
	#ifndef COOL_H
	#include "compiler.h"
	#endif
%}

%define parse.error verbose

%start program

%token UMIN MULT DIV ADD SUB ID EXM THIS SUPER OVERRIDE NULLVAL NATIVE EXTENDS IF ELSE WHILE MATCH CASE STRING INTEGER BOOL CLASS TYPE SEMICOLON COLON EQEQ LTEQ LT EQ NEW DEF PAR_OPEN PAR_CLOSE BRACE_OPEN BRACE_CLOSE VAR DOT COMMA ARROW

%left EQ
%left IF WHILE
%left MATCH
%left LTEQ LT
%left EQEQ
%left ADD SUB
%left MULT DIV
%left EXM UMIN
%left DOT
%left ELSE
%left W

%union {
	StringNode* string;
	IntNode* Int;
	BoolNode* Bool;
	Node* node;
	programNode* program;
	classdeclNode* classdecl;
	varformalsNode* varformals;
	varformNode* varform;
	classbodyNode* classbody;
	featuresNode* features;
	formalsNode* formals;
	formNode* form;
	actualsNode* actuals;
	actualNode* actual;
	blockNode* block;
	blockptNode* blockpt;
	exprNode* expr;
	casesNode* cases;
	casNode* cas;
}

%type <program> program
%type <classdecl> classdecl
%type <varformals> varformals
%type <varform> varform
%type <classbody> classbody
%type <features> features
%type <formals> formals
%type <form> form
%type <actuals> actuals
%type <actual> actual
%type <block> block
%type <blockpt> blockpt
%type <expr> expr
%type <cases> cases
%type <cas> cas

//stmt: error ';'  /* On error, skip until ';' is read.  */

%%

program		: classdecls															{}
/* error */ | error																	{}
			;

classdecls	: classdecl																{}
			| classdecl classdecls													{}
/* error */ | error classdecls														{}
			;

classdecl  	: CLASS type varformals classbody										{}
			| CLASS type varformals EXTENDS type actuals classbody					{}
			| CLASS type varformals EXTENDS NATIVE classbody						{}
/* error */ |  error type varformals classbody										{}
/* error */ | CLASS error varformals classbody										{}
/* error */ | CLASS type error classbody											{}
/* error */ | error type varformals EXTENDS type actuals classbody					{}
/* error */ | CLASS error varformals EXTENDS type actuals classbody					{}
/* error */ | CLASS type error EXTENDS type actuals classbody						{}
/* error */ | CLASS type varformals error type actuals classbody					{}
/* error */ | CLASS type varformals EXTENDS error actuals classbody					{}
/* error */ | CLASS type varformals EXTENDS type error classbody					{}
/* error */ | error type varformals EXTENDS NATIVE classbody						{}
/* error */ | CLASS error varformals EXTENDS NATIVE classbody						{}
/* error */ | CLASS type error EXTENDS NATIVE classbody								{}
/* error */ | CLASS type varformals error NATIVE classbody							{}
/* error */ | CLASS type varformals EXTENDS error classbody							{}
	        ;

varformals	: PAR_OPEN PAR_CLOSE													{}
			| PAR_OPEN varform PAR_CLOSE											{}
/* error */ | error PAR_CLOSE														{}
/* error */ | error varform PAR_CLOSE												{}
/* error */ | PAR_OPEN error PAR_CLOSE												{}
			;

varform		: VAR id COLON type														{}
			| varform COMMA VAR id COLON type 										{}
/* error */ | error id COLON type													{}
/* error */ | VAR error COLON type													{}
/* error */ | VAR id error type														{}
/* error */ | error COMMA VAR														{}
			;

classbody	: BRACE_OPEN features BRACE_CLOSE										{}
			;

features	: /* empty */															{}
			| features DEF id formals COLON type EQ expr SEMICOLON					{}
			| features OVERRIDE DEF id formals COLON type EQ expr SEMICOLON			{}
			| features DEF id formals COLON type EQ NATIVE SEMICOLON				{}
			| features OVERRIDE DEF id formals COLON type EQ NATIVE SEMICOLON		{}
			| features VAR id EQ NATIVE SEMICOLON									{}
			| features VAR id COLON type COLON expr SEMICOLON						{}
			| features BRACE_OPEN block BRACE_CLOSE SEMICOLON						{}
			;

formals		: PAR_OPEN PAR_CLOSE													{}
			| PAR_OPEN form PAR_CLOSE												{}
			;

form 		: id COLON type															{}
			| form COMMA id COLON type 												{}
			;

actuals		: PAR_OPEN PAR_CLOSE													{}
			| PAR_OPEN actual PAR_CLOSE												{}
			;

actual 		: expr																	{}
			| actual COMMA expr 													{}
			;

block 		: /* empty */															{}
			| expr																	{}
			| blockpt																{}
			;

blockpt		: expr SEMICOLON expr													{}
			| expr SEMICOLON blockpt												{}
			| VAR id COLON type EQ expr SEMICOLON expr								{}
			| VAR id COLON type EQ expr SEMICOLON blockpt							{}
			;

id			: ID																	{}
			;

type		: TYPE																	{}
			;

expr		: id EQ expr															{}
			| EXM expr																{}
			| SUB expr %prec UMIN													{}
			| IF PAR_OPEN expr PAR_CLOSE expr ELSE expr %prec W						{}
			| WHILE PAR_OPEN expr PAR_CLOSE expr %prec W							{}
			| SUPER DOT id actuals													{}
			| id actuals															{}
			| NEW type actuals														{}
			| BRACE_OPEN block BRACE_CLOSE											{}
			| PAR_OPEN expr PAR_CLOSE												{}
			| expr DOT id actuals													{}
			| expr MATCH cases														{}
			| expr LTEQ expr 														{}
			| expr LT expr															{}
			| expr EQEQ expr														{}
			| expr MULT expr														{}
			| expr DIV expr															{}
			| expr ADD expr															{}
			| expr SUB expr															{}
			| NULLVAL																{}
			| PAR_OPEN PAR_CLOSE													{}
			| id																	{}
			| INTEGER																{}
			| STRING																{}
			| BOOL																	{}
			| THIS																	{}
			;

cases		: BRACE_OPEN cas BRACE_CLOSE 											{}
			;

cas 		: CASE id COLON type ARROW block										{}
			| cas CASE id COLON type ARROW block									{}
			| CASE NULLVAL ARROW block 												{}
			| cas CASE NULLVAL ARROW block											{}
			;


%%
